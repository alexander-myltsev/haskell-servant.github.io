<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>2016-03-19-servant-js - haskell-servant</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">servant</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../blog.html">Blog</a>
                <a href="../tutorial">Tutorial</a>
                <a href="../tips.html">Tips and tricks</a>
                <a href="../talks.html">Talks</a>
                <a href="https://github.com/haskell-servant/servant">Github</a>
            </div>
        </div>

        <div id="content">
            <h1>2016-03-19-servant-js</h1>

            <p>itle: New JavaScript Generators author: Freezeboy date: 2016-03-17 00:00 toc: true —</p>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>In the upcoming Servant version, it will be way easier to build a javascript connector to your webservice. The chosen API is <em>as usual with Servant</em> putting the hard work away from your eyes to let you concentrate on what you are working on in most situations.</p>
</section>
<section id="the-problem" class="level1">
<h1>The Problem</h1>
<p>Until recently, we had a javascript generator using exclusively JQuery, but depending on the framework you might want to use in your project, it can be overkill to fetch <a href="http://jquery.org">JQuery</a>, or else you are using a library that prefers doing things differently, such as <a href="http://angular.io">AngularJS</a>, which contains its own solution to handle Ajax calls. On the other hand, sometimes your need is so simple that you don’t even want JQuery.</p>
<p>One solution could have been to have multiple packages <code>servant-jquery</code>, <code>servant-angular</code>, and so on… But we chose to put them all in the same package because the generators share lots of <em>problems &amp; solutions</em>.</p>
<p>We have to provide a function for each endpoint defined in the API, with as many parameter as needed. In most cases the client application will simply call these functions throughout its flow.</p>
</section>
<section id="how-do-i-use-it" class="level1">
<h1>How do I use it?</h1>
<p>A complete example is present in the <a href="../tutorial/javascript.html">tutorial</a>.</p>
<p>Basically you can define your API as <a href="../tutorial/api-type.html">usual</a>,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ServerAPI</span> <span class="fu">=</span> realAPI    <span class="co">-- ^ This is the real api</span>
         <span class="fu">:&lt;|&gt;</span> <span class="dt">Raw</span>   <span class="co">-- ^ As a helper, we will provide the</span>
                    <span class="co">-- js file at the root of the API</span>

<span class="ot">serverApi ::</span> <span class="dt">Proxy</span> <span class="dt">ServerAPI</span>
serverApi <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>And now, we just have to generate the client code</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generateApi ::</span> <span class="dt">IO</span> ()
generateApi <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- we generate different versions of the API</span>
    writeJsForApi realAPI angular <span class="st">&quot;angular.js&quot;</span>
    writeJsForApi realAPI vanilla <span class="st">&quot;vanilla.js&quot;</span></code></pre></div>
<p>And we <a href="../tutorial/server.html">serve</a> the bundle to the world</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    generateApi
    <span class="co">-- And now let serve it</span>
    run (serve serverApi) <span class="dv">8000</span></code></pre></div>
</section>
<section id="what-changed" class="level1">
<h1>What changed</h1>
<section id="api-simplification" class="level2">
<h2>API simplification</h2>
<p>Since last release, we drastically simplified the API so that it is easier to use and to extend (if you want to use the <em>next new javascript framework</em>).</p>
</section>
<section id="more-options" class="level2">
<h2>More options</h2>
<p>A simple “configuration” mechanism lets you</p>
<ul>
<li>Rename <em>success</em> and <em>error</em> callbacks</li>
<li>prefix your function definitions (to put them in a namespace, or simply change the name)</li>
<li>even customize the naming heuristics</li>
</ul>
<p>The angular generator even has more options specific to Angular.js, unlike JQuery and Vanilla javascript ones.</p>
</section>
<section id="what-javascript-flavours-do-we-support" class="level2">
<h2>What JavaScript flavours do we support?</h2>
<p>Now we support different backends:</p>
<ul>
<li>Vanilla JS (using XMLHttpRequest)</li>
<li>JQuery (as before)</li>
<li>Axios</li>
<li>Angular.js (As a simple handler, and as a service)</li>
</ul>
</section>
<section id="simpler-interface-to-deal-with-more-environments" class="level2">
<h2>Simpler interface to deal with more environments</h2>
<p>A simple raw XMLHttpRequest-based backend has been included, it can therefore be used without even requiring an external library for the most simple applications.</p>
<p>It is also an opportunity for people writing <a href="http://doc.qt.io/qt-5/qmlapplications.html">Qt5/QML</a> web clients to test Servant. This solution does not rely on a DOM structure. You can write a graphical client to your web service with QML and JS.</p>
<p>If you want to use a Servant API as a backend to your node.js application, it is also possible to connect them using <a href="https://www.npmjs.com/package/xmlhttprequest">this node package</a>.</p>
</section>
<section id="advanced-integration-with-angular" class="level2">
<h2>Advanced integration with Angular</h2>
<p>If you play with Angular applications, you are used to the <em>$http</em> service from the core library. By default, our <code>angular</code> generator creates top level functions that depend on this service (using Angular dependency mechanism).</p>
<p>There is an alternative solution if you simply want an <em>Angular service</em> mapping exactly your <em>Servant service</em>, in this case, generated code will depend on <em>$service</em>.</p>
<p>This extension helped us to define new needs and demonstrate how a more complex generator can be included.</p>
</section>
</section>
<section id="future" class="level1">
<h1>Future</h1>
<p>There is still room for improvements to make the generators even richer in features, and we are open to suggestions. Please play with this tool and tell us if you have any idea.</p>
<p>One particular aspect is about the generated function names. Currently, they are derived from the URL, but we need to deal with potential conflicts.</p>
</section>

<div class="info">
    Posted on March 19, 2016
    
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            -
            <a href="https://github.com/haskell-servant/haskell-servant.github.io">Source</a>
        </div>
    </body>
</html>
